

# This file was *autogenerated* from the file enhanced_pohlig_hellman.sage
from sage.all_cmdline import *   # import sage library

_sage_const_20000000000 = Integer(20000000000); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_0 = Integer(0); _sage_const_100 = Integer(100); _sage_const_795189633901933 = Integer(795189633901933); _sage_const_213666326927748 = Integer(213666326927748)
load("pollard_p.sage")

def enhanced_pohlig_hellman(p: int, g: int, h: int)->int:
    MAX_PRIME_DIVISOR = _sage_const_20000000000  
    order = p-_sage_const_1 
    facs = (order).factor()
    B = max(MAX_PRIME_DIVISOR,floor((_sage_const_2 /_sage_const_3 ) * p))
    if facs[-_sage_const_1 ][_sage_const_0 ] >= B:
        print("The input is not doable, terminating...")
        return -_sage_const_1 

    print("The prime factors are: ", facs)
    bits = []
    #f is factor, e is exponent
    for f,e in facs:
        bits_0 = []
        bit1_0 = _sage_const_0 

        lhs = power_mod(h,order//f,p)  
        if f > _sage_const_100 :
            gPrime = power_mod(g,order//f,p)
            bit1_0 = pollard_rho(p,gPrime,lhs,f)
        else:
            while lhs != power_mod(g,(order//f)*bit1_0,p):
                bit1_0 += _sage_const_1 
        bits_0.append(bit1_0)
        for i in srange(_sage_const_1 ,e):
            bitK_0 = _sage_const_0 
            bits_power = _sage_const_0 
            for j,b in enumerate(bits_0):  
                bits_power += power_mod(f,j,p)*b 
            fe = power_mod(f,i+_sage_const_1 ,p)
            lhs = power_mod(h,order//fe,p)
            rhs_partial = power_mod(g,(order//fe) * bits_power,p)
            if f > _sage_const_100 :
                print("second loop")
                gPrime = power_mod(g,order/f,p) % p
                hPrime = (lhs * power_mod(g,(order//fe) * -bits_power,p)) % p
                bitK_0 = pollard_rho(p,gPrime,hPrime,f) %p
            else:
                while lhs!= (rhs_partial * power_mod(power_mod(g,order//f,p),bitK_0,p))% p:
                    bitK_0 += _sage_const_1 
            bits_0.append(bitK_0)
        bitK = _sage_const_0 
        for i,b in enumerate(bits_0):
            
             bitK += b * power_mod(f,i,p)
        bits.append(bitK)
    # 
    #for the sake of conveniece, i will create a list of factors
    # which add any repeated factors as one proper element 
    facList= []
    for f, e in facs:
        num = _sage_const_1 
        for i in srange(e):
            num *= f
        facList.append(num)
    #lets rename the list of a's too
    A = bits
    print("Applying Sun Tzu's theorem...")
    #Now apply the chinese remainder theorem
    mTotal = _sage_const_1 
    for fac in facList:
        mTotal *= fac
    M = []
    for fac in facList:
        M.append(mTotal//fac)
    X = []
    for i,m in enumerate(M):
        x = inverse_mod(m,facList[i])
        X.append(x)
    res = _sage_const_0 
    for i in range(len(X)):
        res += (A[i] * X[i] * M[i]) % mTotal
        res = res % mTotal
    return res


#print("Answer: ",enhanced_pohlig_hellman(10192004369, 3 , 7198247104)) 
#print("Answer: ",enhanced_pohlig_hellman(11520316802179, 2, 3970483220420)) 
print("Answer: ",enhanced_pohlig_hellman(_sage_const_795189633901933 ,_sage_const_2 ,_sage_const_213666326927748 )) 

